# MusicLake

# Dagger2
  旁白：
  很多小白对于Dagger2是啥浑然不知，更不知其能带来的好处了。这里举个例子，比如有个类A，他的构造函数需要传入B,C；
  然后代码里有10个地方实例化了A，那如果功能更改，A的构造函数改成了只有B，这个时候，你是不是要去这10个地方一个一个的改？如果是100个地方，
  你是不是要吐血？！如果采用dagger2，这样的需求只需要改1-2个地方，你感觉怎么样？对你有诱惑吗？
  也有人怀疑Dagger2利用注解是不是采用了反射，性能怎么样？其实Dagger2、ButterKnife这类依赖注入框架都已经采用了apt代码自动生成技术，
  其注解是停留在编译时，完全不影响性能。
  Dagger2是Google提供的依赖注入框架，依赖注入为Android中组件之间的解耦提供了很好的解决方案。
  使用它可以自动生成创建依赖关系所需要的代码。减少很多模板化的代码，更易于测试，降低耦合，创建可复用可互换的模块。
  已经在越来越多的开源项目中被使用，其已经发展成为未来的一个技术趋势。
  一：Dagger2是什么？
  是一个依赖注入框架，butterknife也是一个依赖注入框架。
  不过butterknife，最多叫奶油刀，Dagger2被叫做利器啊，他的主要作用，就是对象的管理，其目的是为了降低程序耦合。
  二：为什么要有Dagger2
     MVP设计模式中，M层提供数据，V层做界面展示，而P层则成为M和V的桥梁，这其中就必然涉及到M和V的交互及处理，如果业务复杂或者多个页面共用，
     它还是面临着高度的耦合性。如果需求发生变动，必然需要更改P中的内容。而在MVP中，我们通常在activity层中需要拿到p层的对象，
     那么在开发中有可能我们很多activity或者fragment都可能需要拿到这个p层对象的实例，假如我们P层类的构造发生变化(例如增加了参数）
     我们要在很多地方都得进行修改，这就是耦合度太高的弊端。
     为了解决这种耦合性的问题，有一帮牛叉的人就思索着：能不能有个容器，这个容器在我们需要用到某个对象的时候帮我们创建好需要的对象，
     像对象工厂一样，并且帮我们管理这些对象。当发生变化时，我们只需要换一个容器就可以了。就这样，dagger2应运而生。
  三：Dagger2如何使用
     1. 基本的概念
     Dagger 是通过@Inject使用具体的某个对象，这个对象呢，是由@Provides注解提供，
     但是呢，这个@Provides只能在固定的模块中，也就是@Module注解，我们查找的时候，不是直接去找模块，而是去找@Component
     .......
     2. 如何使用Dagger2
        简而言之，dagger2中组成内容的对应关系：
        类Module：使用@Module修饰，装载对象的容器。
        接口Component：使用@Component修饰，存放这些容器的仓库。它是连接Module和依赖注入对象的桥梁。
        注解@Provides：该容器创建对象的动作。
        注解@Inject:从容器中取出这个对象的动作。
        注解@Qualifier：用来给@Inject和@Provides贴上关联标签(进行注解)。如果一个对象可以由一个或多个容器的@Provides修饰提供，这时候就需要用Qualifier进行标签关联。 还不清楚的可点击了解.
        注解@Scope：从容器取出对象的有效期，即生命周期。
  四：@Inject ： 注入，被注解的构造方法会自动编译生成一个Factory工厂类提供该类对象。
     @Component: 注入器，类似快递员，作用是将产生的对象注入到需要对象的容器中，供容器使用。
     @Module: 模块，类似快递箱子，在Component接口中通过@Component(modules =
     xxxx.class),将容器需要的商品封装起来，统一交给快递员（Component），让快递员统一送到目标容器中。